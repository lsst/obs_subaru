static void average_peak_centers(const PEAK *peak1, const PEAK *peak2,
				 float *rowc, float *colc);
static void merge_peaks(PEAK *peak_i, PEAK *peak_j);

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Setup scratch space for the deblender
 */
void
phDeblendSet(REGION *i_scr0,
	     REGION *i_scr1,
	     REGION *i_scr2,
	     REGION *i_scr3)
{
   int i;
   
   scr0 = i_scr0; scr1 = i_scr1; scr2 = i_scr2;

   if(scr0 == NULL) {
      shAssert(scr1 == NULL && scr2 == NULL && i_scr3 == NULL);
      return;
   }

   shAssert(scr0->type == TYPE_PIX);
   shAssert(scr1 != NULL && scr1->type == TYPE_PIX);
   shAssert(scr1->nrow == scr0->nrow && scr1->ncol == scr0->ncol);
   shAssert(scr2 != NULL && scr2->type == TYPE_PIX);
   shAssert(scr2->nrow == scr0->nrow && scr2->ncol == scr0->ncol);
   shAssert(i_scr3 != NULL && i_scr3->type == TYPE_PIX);
   shAssert(i_scr3->nrow == scr0->nrow && i_scr3->ncol == scr0->ncol);
/*
 * we want to make a MASK out of the i_scr3
 */
   shAssert(sizeof(mscr0->rows[0][0]) <= sizeof(PIX));

   mscr0 = shMaskNew("deblender", i_scr3->nrow, 0);
   for(i = 0; i < mscr0->nrow; i++) {
      mscr0->rows[i] = (unsigned char *)i_scr3->ROWS[i];
   }
   mscr0->ncol = i_scr3->ncol;
}

/*****************************************************************************/
/*
 * Note that we don't actually own this scratch space, we merely borrowed
 * it in phDeblendSet
 */
void
phDeblendUnset(void)
{
   scr0 = scr1 = scr2 = NULL;
   mscr0->rows[0] = NULL;		/* memory belongs to i_scr3 */
   shMaskDel(mscr0); mscr0 = NULL;
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Delete all of an OBJC's children
 */
void
phObjcChildrenDel(OBJC *objc)
{
   phObjcDel(objc->sibbs, 1);
   objc->sibbs = NULL;

   phObjcDel(objc->children, 1);
   objc->children = NULL;

   objc->nchild = 0;
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Recalculate an object's centre now that it's been deblended, based
 * on its nominal peak position
 */
void
phDeblendedObjcRecenter(OBJC *objc,	/* the object in question */
			const FIELDPARAMS *fiparams) /* properties of field */
{
   int c;
   const REGION *data;			/* == fiparams->frame[c].data */
   float drow, dcol;			/* offsets from reference colour */
   OBJECT1 *obj1;
   int rpeak, cpeak;			/* peak pixel of an object */
   float threshold;			/* threshold for accepting peaks */

   shAssert(objc != NULL && fiparams != NULL);
   
   for(c = 0;c < objc->ncolor;c++) {
      obj1 = objc->color[c];
      
      if(obj1 == NULL) {
	 continue;
      }
/*
 * Was the centre already estimated for missing detections of this object,
 * based on it's motion?
 */
      if(objc->flags2 & OBJECT2_DEBLENDED_AS_MOVING) {
	 continue;
      }
/*
 * See if the peak was bright enough to have been detected, but wasn't;
 * this can happen to children due to the vagueries of peak matching
 */
      if(objc->parent == NULL) {
	 continue;
      }

      if(obj1->peaks == NULL || obj1->peaks->npeak == 0) {
	 shAssert(!(obj1->flags & OBJECT1_DETECTED));

	 phOffsetDo(fiparams, objc->rowc, objc->colc, 
		    fiparams->ref_band_index, c,
		    1, NULL, NULL, &drow, NULL, &dcol, NULL);

	 rpeak = objc->rowc + drow;
	 cpeak = objc->colc + dcol;
	 data = fiparams->frame[c].data;
	 shAssert(data != NULL);
	 
	 threshold = fiparams->frame[c].ffo_threshold +
					   fiparams->frame[c].bkgd + SOFT_BIAS;

	 if(rpeak < 0 || rpeak >= data->nrow ||
	    cpeak < 0 || cpeak >= data->ncol ||
					data->ROWS[rpeak][cpeak] < threshold) {
	    continue;
	 } else {
	    obj1->flags  |= OBJECT1_BINNED1;
	    obj1->flags2 |= OBJECT2_DEBLEND_NOPEAK;
	    
	    if(obj1->peaks == NULL) {
	       obj1->peaks = phPeaksNew(1);
	    } else {
	       phPeaksRenew(obj1->peaks, 1);
	    }
	    
	    obj1->peaks->npeak = 1;
	    obj1->peaks->peaks[0]->rpeak = rpeak;
	    obj1->peaks->peaks[0]->cpeak = cpeak;
	 }
      }

      phObject1CenterFit(obj1, fiparams->frame[c].data,
			 &fiparams->frame[c], 32, ALWAYS_SMOOTH);
   }

   if(objc->peaks != NULL) {
      objc->peaks->npeak = 0;		/* discard old peaks list */
   }
   phObjcPeaksSetFromObject1s(objc, fiparams);
  
   objc->flags3 &= ~OBJECT3_HAS_CENTER;
   phObjcCenterCalc(objc, fiparams, 0);	/* find canonical centre */
}



/*
 * Set up the normal equations, Aw = b
 */
static void
setup_normal(const OBJC *parent,	/* parent object */
	     const OBJC **children,	/* array of children */
	     int nchild,		/* dimension of children[] */
	     int c,			/* the colour in question */
	     int bkgd,			/* == (bkgd from fparams) + SOFT_BIAS*/
	     MAT *A,			/* The LSQ problem is */
	     VEC *b,			/*    A w = b */
	     VEC *norm)			/* normalisation of templates */
{
   int i, j;
   float *maxpix = alloca(nchild*sizeof(float)); /* max. value for templates */
   int npix = parent->aimage->master_mask->npix;

   for(i = 0;i < nchild;i++) {
      shAssert(children[i]->aimage->master_mask->npix == npix);
   }
/*
 * First A.
 */
   for(i = 0;i < nchild;i++) {
      for(j = 0;j <= i;j++) {
	  A->me[i][j] = A->me[j][i] = phAtlasImageDotProduct(children[i]->aimage, c, bkgd,
							     children[j]->aimage, c, bkgd);
      }
   }
/*
 * and now b
 */
   for(i = 0;i < nchild; i++) {
      b->ve[i] = phAtlasImageDotProduct(children[i]->aimage, c, bkgd,
					parent->aimage,      c, bkgd);

      maxpix[i] = phAtlasImageMaximum(parent->aimage, c) - bkgd;
      if(maxpix[i] <= 0) {
	  maxpix[i] = 1;			/* don't divide by zero */
      }
   }
/*
 * Now renormalise to try to control overflows etc., and to make the values
 * of the eigenvalues more comprehensible. We renormalise each template
 * to have a maximum value of unity rather than an rms of unity to avoid
 * problems with poorly known sky levels
 */
   for(i = 0;i < nchild;i++) {
      norm->ve[i] = maxpix[i];
      b->ve[i] /= maxpix[i];
      for(j = 0;j <= i;j++) {
	 A->me[i][j] /= maxpix[i]*maxpix[j];
	 A->me[j][i] = A->me[i][j];
      }
   }
/*
 * write out template and data vectors, for debugging
 */
#if 0
   {
      FILE *fil = fopen("template.dat","w");
      if(fil != NULL) {
	  const OBJMASK *mmask = parent->aimage->master_mask;
	  for(k = 0; k < mmask->nspan; k++) {
	      int x1 = mmask->s[k].x1, x2 = mmask->s[k].x2;
	      int x;
	      int y = mmask->s[k].y;

	      fprintf(fil,"(%d, %d): ", y, x);
	      for(x = x1; x <= x2; x++) {
		  fprintf(fil," %d", phAtlasImagePixelGet(parent->aimage, c, y, x));
		  for(j = 0; j < nchild;j++) {
		      fprintf(fil," %d", phAtlasImagePixelGet(children[j]->aimage, c, y, x));
		  }
	      }
	      fprintf(fil,"\n");
	  }
	  fclose(fil);
      }
   }
#endif
}

/*****************************************************************************/
/*
 * Find the sum of I_i * r_i^2 for an object in a given band
 *
 * Note that, because the master mask's in the canonical band, that's
 * the coordinate system we use in this routine
 */
static float
find_Isigma2(const OBJC *objc,		/* the object in question */
	     int c,			/* in this band */
	     int bkgd)			/* background level */
{
   const int colc = objc->color[c]->colc - objc->aimage->dcol[c] + 0.5;
   int i;				/* span counter */
   const OBJMASK *mmask = objc->aimage->master_mask;
   const int nspan = mmask->nspan;
   int peakval;				/* peak value in objc */
   int r2;				/* == (distance from object centre)^2*/
   const int rowc = objc->color[c]->rowc - objc->aimage->drow[c] + 0.5;
   int row2, col2;			/* == ({row,col} - {row,col}c)^2 */
   float sum = 0;			/* the desired sum */
   int val;				/* == pix[j] */
   int x, y;				/* column/row counters */
   int x1, x2;				/* ends of this span */

   if(objc->color[c]->peaks == NULL || objc->color[c]->peaks->npeak == 0) {
      return(0.0);
   }
   
   peakval = 1.1*objc->color[c]->peaks->peaks[0]->peak + bkgd;

   for(i = 0; i < nspan; i++) {
      x1 = mmask->s[i].x1; x2 = mmask->s[i].x2;
      y = mmask->s[i].y;

      row2 = y - rowc; row2 *= row2;
      col2 = x1 - colc; col2 *= col2;
      for(x = x1; x <= x2; x++) {
	 r2 = row2 + col2;
	 val = phAtlasImagePixelGet(objc->aimage, c, y, x);
	 if(val > bkgd && val < peakval) {
	    sum += (val - bkgd)*r2;
	 }

	 col2 += 2*(x - colc) + 1;	/* ((x-xc)+1)^2 == (x-xc)^2+2(x-xc)+1*/
      }
   }

   return(sum);
}

#endif // NOPE

#if defined(NOPE)

/*****************************************************************************/
/*
 * If we are reduced to only a single child, make sure that the parent
 * has the child's positions in all bands; as the parent was a deblend
 * candidate it may have a mixture of the candidate peaks
 */
static void
set_parent_position_from_child(OBJC *objc,
			       const OBJC *child)
{
   int c;

   objc->flags &= ~OBJECT1_CANONICAL_CENTER;
   objc->flags |= (child->flags & OBJECT1_CANONICAL_CENTER);
   objc->rowc = child->rowc;
   objc->rowcErr = child->rowcErr;
   objc->colc = child->colc;
   objc->colcErr = child->colcErr;
   
   for(c = 0; c < objc->ncolor; c++) {
      objc->color[c]->flags &= ~OBJECT1_CANONICAL_CENTER;
      objc->color[c]->flags |=
	(child->color[c]->flags & OBJECT1_CANONICAL_CENTER);
      objc->color[c]->rowc = child->color[c]->rowc;
      objc->color[c]->rowcErr = child->color[c]->rowcErr;
      objc->color[c]->colc = child->color[c]->colc;
      objc->color[c]->colcErr = child->color[c]->colcErr;
   }
}

/*****************************************************************************/
/*
 * Reject a template
 */
static int
reject_template(OBJC *objc,
		int nchild,
		int reject,
		OBJC *children[],
		ATLAS_IMAGE *smoothed_ai[],
		MAT *A[],
		VEC *b[],
		VEC *norm[],
		VEC *lambda[],
		MAT *Q[],
		VEC *w[])
{
   int c;
   int i;

   objc->flags |= OBJECT1_DEBLEND_PRUNED;
   for(c = 0; c < objc->ncolor; c++) {
      objc->color[c]->flags |= OBJECT1_DEBLEND_PRUNED;
   }
/*
 * and reject it
 */
   phObjcChildDel(children[reject]);
   phAtlasImageDel(smoothed_ai[reject], 0);
   for(i = reject;i < nchild - 1;i++) { /* move the others down */
      children[i] = children[i + 1];
      smoothed_ai[i] = smoothed_ai[i + 1];
   }
   nchild--;
   
   for(c = 0; c < objc->ncolor; c++) { /* reject from Normal eqs.*/
      A[c] = phMatDelRowCol(A[c], reject, reject);
      b[c] = phVecDelElement(b[c], reject);
      norm[c] = phVecDelElement(norm[c], reject);
      phVecDel(w[c]); w[c] = NULL;
   }

   if(nchild <= 1) {
      for(c = 0; c < objc->ncolor; c++) {
	 phMatDel(A[c]);
	 phVecDel(b[c]);
	 phVecDel(norm[c]);
	 phVecDel(lambda[c]);
	 phMatDel(Q[c]);
      }
      
      if(nchild == 1) {
	 set_parent_position_from_child(objc, children[0]);
      }
      
      objc->flags |= OBJECT1_NODEBLEND;
      for(c = 0; c < objc->ncolor; c++) {
	 objc->color[c]->flags |= OBJECT1_NODEBLEND;
      }
      shFree(children);
      for(i = 0;i < nchild;i++) {
	 phAtlasImageDel(smoothed_ai[i], 0);
      }
      shFree(smoothed_ai);
      return(0);
   }

   return(nchild);
}

/*****************************************************************************/
/*
 * Copy peaks in reject into keep, if the object isn't detected in that
 * band in object keep.  Move the centroid over too, as it came from the peaks
 */
static void
transfer_centers_and_peaks(OBJC *keep, OBJC *reject)
{
   int c;
   
   for(c = 0; c < keep->ncolor; c++) {
      if((keep->color[c]->flags & OBJECT1_DETECTED) != 0 ||
	 reject->color[c]->peaks == NULL) {
	 continue;			/* nothing to do */
      }

      phPeaksDel(keep->color[c]->peaks);
      keep->color[c]->peaks = reject->color[c]->peaks;
      reject->color[c]->peaks = NULL;
/*
 * We should copy over the centers too, but it seems rather scary to do
 * so at this late stage (v5_4_24).
 */
#if 1
      keep->color[c]->rowc = reject->color[c]->rowc;
      keep->color[c]->rowcErr = reject->color[c]->rowcErr;
      keep->color[c]->colc = reject->color[c]->colc;
      keep->color[c]->colcErr = reject->color[c]->colcErr;
#endif
      
      keep->flags &= ~OBJECT1_CANONICAL_CENTER; /* we need reject's value of */
      keep->color[c]->flags &= ~OBJECT1_CANONICAL_CENTER; /* CANONICAL_CENTER*/
      
      keep->flags |= reject->color[c]->flags & OBJECT1_DETECTED;
      keep->color[c]->flags |= reject->color[c]->flags & OBJECT1_DETECTED;
   }
}

/*****************************************************************************/
/*
 * look at the potential children and see if there are any `local'
 * modifications to the list that would improve the deblend.
 *
 * Initially, the only such case is re-assembling unrecognised moving objects
 */

static int
peephole_optimizer(OBJC *objc,		/* parent */
		   const FIELDPARAMS *fiparams, /* astrometry etc. */
		   int nchild,		/* number of children */
		   OBJC *children[],	/* list of children */
		   ATLAS_IMAGE **smoothed_ai)/* list of atlas images containing
						smoothed templates. Not used,
						but may need to be freed */
		   
{
   int c;				/* counter in colour */
   float col[NCOLOR], colErr[NCOLOR];	/* estimated col centre in each band */
   OBJC *child;				/* == children[] */
   int *detected;			/* Which bands are present
						   in each of the children[] */
   float drow[NCOLOR], dcol[NCOLOR];	/* _Add_ to convert to canon. band */
   float drowErr[NCOLOR], dcolErr[NCOLOR]; /* errors in drow/dcol */
   int i, j;
   OBJC *merged = NULL;			/* candidate merged object */
   const float min_peak_spacing = fiparams->deblend_min_peak_spacing;
   int did_merge = 0;			/* did I merge any bands together? */
   float row[NCOLOR], rowErr[NCOLOR];	/* estimated row centre in each band */
/*
 * Find astrometric offsets
 */
   for(c = 0; c < objc->ncolor; c++) {
      phOffsetDo(fiparams, objc->rowc, objc->colc, 
		 c, fiparams->ref_band_index,
		 0, NULL, NULL, &drow[c], &drowErr[c], &dcol[c], &dcolErr[c]);
   }
/*
 * Go through list of children setting bits for which bands are present;
 * not totally by coincidence these are the same as PEAK_BAND0 etc. although
 * we don't use this fact.
 */
   detected = shMalloc(nchild*sizeof(int));

   for(i = 0; i < nchild; i++) {
      child = children[i];
      detected[i] = 0;
      for(c = 0; c < objc->ncolor; c++) {
	 if(child->color[c]->flags & OBJECT1_DETECTED) {
	    detected[i] |= (1 << c);
	 }
      }
   }
/*
 * Go through all pairs of children that don't have any peaks in
 * common, and see if it makes sense to merge them
 */
   for(i = 0; i < nchild; i++) {
      for(j = i + 1; j < nchild; j++) {
	 if((detected[i] & detected[j]) != 0) { /* they have bands in common */
	    continue;
	 }
	 /*
	  * Copy OBJECT1s from i and j into merged
	  */
	 if(merged == NULL) {
	    merged = phObjcNew(objc->ncolor);
	 }
	 for(c = 0; c < objc->ncolor; c++) {
	    if((detected[i] & (1 << c))) {
	       merged->color[c] = children[i]->color[c];
	    } else if((detected[j] & (1 << c))) {
	       merged->color[c] = children[j]->color[c];
	    }
	 }
	 /*
	  * estimate the velocity
	  */
	 if(phVelocityFind(merged, fiparams,
			   row, rowErr, col, colErr, NULL) != 0) {
	    for(c = 0; c < objc->ncolor; c++) {	/* Not a good candidate */
	       merged->color[c] = NULL;
	    }
	    
	    continue;
	 }
	 /*
	  * Hmm, a good candidate for a merger.  Replace i with merged
	  * (well, actually overlay i with merged) and prepare to discard j
	  */
	 {
	    long mask = ~(OBJECT2_NODEBLEND_MOVING |
			  OBJECT2_BAD_MOVING_FIT |
			  OBJECT2_BAD_MOVING_FIT_CHILD |
			  OBJECT2_TOO_FEW_DETECTIONS);

	    objc->flags2 &= mask;
	    children[i]->flags2 &= mask;
	 }

	 objc->flags2 |=
	    OBJECT2_DEBLENDED_AS_MOVING | OBJECT2_DEBLEND_PEEPHOLE;
	 children[i]->flags2 |=
	    OBJECT2_DEBLENDED_AS_MOVING | OBJECT2_DEBLEND_PEEPHOLE;
	 did_merge = 1;

	 detected[i] |= detected[j];

	 for(c = 0; c < objc->ncolor; c++) {
	    if(merged->color[c] == NULL) {
	       OBJECT1 *obj1 = children[i]->color[c];
	       shAssert(obj1 != NULL);
	       if(obj1->flags & OBJECT1_DETECTED) {
		  shAssert(obj1->flags & OBJECT1_CANONICAL_CENTER);
	       }
	       
	       obj1->colc = col[c] - dcol[c];
	       obj1->colcErr = sqrt(pow(colErr[c],2) + pow(dcolErr[c],2));
	       obj1->rowc = row[c] - drow[c];
	       obj1->rowcErr = sqrt(pow(rowErr[c],2) + pow(drowErr[c],2));
	       
	       obj1->flags |= OBJECT1_CANONICAL_CENTER;
	    } else {
	       if(children[i]->color[c] == merged->color[c]) {
		  ;			/* nothing to do */
	       } else if(children[j]->color[c] == merged->color[c]) {
		  phObject1Del(children[i]->color[c]);
		  children[i]->color[c] = merged->color[c];
		  children[j]->color[c] = NULL;
		  
		  shAssert(children[i]->aimage->mask[c] == NULL);
		  children[i]->aimage->mask[c] = children[j]->aimage->mask[c];
		  children[j]->aimage->mask[c] = NULL;
		  
		  phAtlasImagePixReplace(children[i]->aimage, c, children[j]->aimage, c);
		  phAtlasImagePixReplace(smoothed_ai[i],      c, smoothed_ai[j],      c);
	       } else {
		  shFatal("You cannot get here");
	       }
	       
	       merged->color[c] = NULL;
	    }
	 }
	 /*
	  * and discard j, filling its slot in children[]
	  */
	 phObjcChildDel(children[j]); children[j] = NULL;
	 phAtlasImageDel(smoothed_ai[j], 0);

	 for(; j < nchild - 1; j++) {
	    detected[j] = detected[j + 1];
	    children[j] = children[j + 1];
	    smoothed_ai[j] = smoothed_ai[j + 1];
	 }

	 nchild--;

	 i--;				/* try a further merge */
	 break;				/*       by continuing with i loop */
      }
   }
/*
 * If we merged any children to create a new moving object, see if
 * there are other detections of the moving object that weren't merged
 * into the new object.  In other words, look for detections in other
 * children at the correct calculated position.
 *
 * We need to do this to avoid shredding objects that now appear in
 * two objects 
 */
   if(did_merge) {
      for(i = 0; i < nchild; i++) {
	 if(!(children[i]->flags2 & OBJECT2_DEBLEND_PEEPHOLE)) {
	    continue;
	 }

	 for(j = 0; j < nchild; j++) {
	    int nmatch_j = 0;		/* number of matched objects in j */

	    if(i == j) {
	       continue;
	    }
	    if((detected[i] & detected[j]) != 0) { /* bands in common */
	       continue;
	    }

	    for(c = 0; c < objc->ncolor; c++) {
	       OBJECT1 *obj1_i = children[i]->color[c];
	       OBJECT1 *obj1_j = children[j]->color[c];
	       float rowc_i, rowcErr_i, colc_i, colcErr_i;
	       float rowc_j, rowcErr_j, colc_j, colcErr_j;

	       if((obj1_i->flags & OBJECT1_DETECTED) ||
		  !(obj1_j->flags & OBJECT1_DETECTED)) {
		  continue;
	       }

	       rowc_i = obj1_i->rowc;
	       colc_i = obj1_i->colc;
	       rowcErr_i = obj1_i->rowcErr;
	       colcErr_i = obj1_i->colcErr;

	       rowc_j = obj1_j->rowc;
	       colc_j = obj1_j->colc;
	       rowcErr_j = obj1_j->rowcErr;
	       colcErr_j = obj1_j->colcErr;

	       if(pow(fabs(rowc_i - rowc_j) - rowcErr_i - rowcErr_j, 2) +
		  pow(fabs(colc_i - colc_j) - colcErr_i - colcErr_j, 2) <
					   min_peak_spacing*min_peak_spacing) {
		  obj1_i->flags |= (obj1_j->flags & OBJECT1_DETECTED);
		  nmatch_j++;
	       } else {
		  break;
	       }
	    }

	    if(c == objc->ncolor && nmatch_j > 0) { /* all peaks match */
	       /*
		* and discard j, filling its slot in children[]
		*/
	       phObjcChildDel(children[j]); children[j] = NULL;
	       phAtlasImageDel(smoothed_ai[j], 0);
	       
	       for(; j < nchild - 1; j++) {
		  detected[j] = detected[j + 1];
		  children[j] = children[j + 1];
		  smoothed_ai[j] = smoothed_ai[j + 1];
	       }
	       
	       nchild--;
	       
	       i--;			/* try a further merge */
	       break;			/*       by continuing with i loop */
	    }
	 }
      }
   }
/*
 * Clean up
 */
   if(merged != NULL) {
      for(c = 0; c < objc->ncolor; c++) {
	 merged->color[c] = NULL;	/* merged never owned them */
      }
      phObjcDel(merged, 1);
   }
   shFree(detected);

   return(nchild);
}

/************************************************************************************************************/
/*
 * Calculate the inner product of a pair of columns of two matrices
 */
static double
columnDotColumn(const MAT *Q1, const MAT *Q2, /* the two matrices */
		const int c1, const int c2) /* the two columns */
{
    int i;
    double sum = 0;

    for (i = 0; i < Q1->n; i++) {
	sum += Q1->me[i][c1]*Q2->me[i][c2];
    }

    return sum;
}

/*
 * Swap columns c1 and c2 of matrix Q and the corresponding
 * elements of vector lambda (if non-NULL)
 */
static void
swap_columns(MAT *Q, VEC *lambda,
	     const int c1, const int c2)
{
    int i;

    if (c1 == c2) return;

    for (i = 0; i < Q->n; i++) {
	const double tmp = Q->me[i][c1];
	Q->me[i][c1] = Q->me[i][c2];
	Q->me[i][c2] = tmp;
    }

    if (lambda != NULL) {
	const double tmp = lambda->ve[c1];
	lambda->ve[c1] = lambda->ve[c2];
	lambda->ve[c2] = tmp;
    }
}

/************************************************************************************************************/
/*
 * Given a set of Q and lambda (the eigenvectors and values of a matrix),
 * one for each of a set of colours, sort the eigenobjects so that they
 * are in the same order as the canonical colour.  This is done by looking
 * at each eigenvector in turn, and seeing with which eigenvector in
 * Q[canonical_color] it has the largest |inner product|
 */
static void
sort_Q(const int ncolor,		/* dimen of lambda and Q arrays */
       const int canonical_color,	/* sort to match this colour */
       VEC **lambda,			/* eigenvalues */
       MAT **Q)				/* eigenvectors */
{
    int c;
    int i, j;

    for (c = 0; c < ncolor; c++) {
	if (c == canonical_color) continue; /* already sorted */

	for (i = 0; i < Q[c]->m; i++) {
	    int best_column = i;
	    double best_dot = columnDotColumn(Q[canonical_color], Q[c], i, best_column);
	    for (j = i + 1; j < Q[c]->m; j++) {
		double dot = columnDotColumn(Q[canonical_color], Q[c], i, j);
		if (fabs(dot) > fabs(best_dot)) {
		    best_column = j;
		    best_dot = dot;
		    
		}
	    }
	    swap_columns(Q[c], lambda[c], i, best_column);
	}
    }
}

/*****************************************************************************/
/*
 * Average the per-band templates.
 *
 * This is a bit of a pain... First set the pixels outside the detection footprint to SOFT_BIAS (not 0),
 * then add a fraction 1/ncolor of each template to the 0th (also scaled down by 1/ncolor); this scaling
 * avoids overflows.  Then clip the resulting mean template to the union of the input masks, and copy
 * it back into the per-band templates.
 */
static void
average_templates(OBJC *child)
{
    int c;
    OBJMASK *mask = phObjmaskCopy(child->color[0]->mask, 0, 0);
    
    for(c = 0; c < child->ncolor;c++) {
	OBJECT1 *obj1 = child->color[c];
	phAtlasImageSetIfNotInObjmask(child->aimage, c, obj1->mask, SOFT_BIAS);

	phAtlasImagesTimesEquals(child->aimage, c, 1/(float)child->ncolor);
	if (c > 0) {
	    phObjmaskOrObjmask(mask, child->color[c]->mask);
	    phAtlasImagesPlusEquals(child->aimage, 0, child->aimage, c, 0);
	}
    }
	   
    for(c = 0; c < child->ncolor;c++) {
	phAtlasImageSetIfNotInObjmask(child->aimage, c, mask, 0);
	if (c > 0) {
	    phAtlasImagesPixelsCopy(child->aimage, c, child->aimage, 0);
	}
    }

    phObjmaskDel(mask);
}

/*****************************************************************************/
/*
 * go through a set of children's atlas images, and for pixels where the
 * sum of the children's fluxes doesn't equal the parent, assign the balance
 * based on Is2/R^2
 *
 * Return the total number of DN that this routine was forced to share out
 * among the children
 */
static float
assign_missing_flux(const OBJC **children, /* the children in question */
		    int nchild,		/* number of children */
		    int c,		/* in this band */
		    const float *Is2)	/* children's I*sigma^2 values */
{
   int best_k;				/* best choice of child to get flux */
   const OBJC *child;			/* == children[k] */
   int drow, dcol;			/* distance to an object's centre */
   int i, j, k;				/* span and pixel counter resp. */
   float max;				/* maximum weight of any object */
   const OBJMASK *mmask = children[0]->parent->aimage->master_mask;
   const int nspan = mmask->nspan;
   int r2;				/* == (distance from object centre)^2*/
   float unassigned = 0;		/* flux unassigned to any object */
   int val;				/* value of a pixel to be assigned */
   float weight;			/* an object's weight */
#define USE_WEIGHTS 0
#if USE_WEIGHTS
   float *weights = alloca(nchild*sizeof(float)); /* weights for all children */
#endif
   int x;				/* column counter */
   int y, x1, x2;			/* SPAN.{y,x[12]} */
/*
 * assign fluxes
 */
   for(i = j = 0; i < nspan; i++) {
      y = mmask->s[i].y;
      x1 = mmask->s[i].x1; x2 = mmask->s[i].x2;
      for(x = x1; x <= x2; x++, j++) {
	 for(k = 0; k < nchild; k++) {
	    if(phAtlasImagePixelGet(children[k]->aimage, c, y, x) != SOFT_BIAS) {
	       break;			/* we assigned flux to someone */
	    }
	 }
	 if(k == nchild) {		/* unassigned pixel */
#if USE_WEIGHTS
	    double sum = 0;
	    val = phAtlasImagePixelGet(children[0]->parent->aimage, c, y, x) - SOFT_BIAS;
	    max = -1e9; best_k = 0;
	    for(k = 0; k < nchild; k++) {
	       child = children[k];
	       drow = y - child->rowc + 0.5;
	       dcol = x - child->colc + 0.5;
	       r2 = drow*drow + dcol*dcol;
	       if(r2 == 0) {
		  best_k = k;
		  break;
	       }

	       if(weight > max) {
		  max = weight; best_k = k;
	       }

	       weight = weights[k] = Is2[k]/r2;
	       sum += weight;
	    }
	    if(k < nchild) {
		phAtlasImagePixelSet(children[k]->aimage, c, y, x, val + SOFT_BIAS);
	    } else {
		for(k = 0; k < nchild; k++) {
		    int dval = val*weights[k]/sum + 0.5;
		    if(dval > 0) {
			phAtlasImagePixelSet(children[k]->aimage, c, y, x, dval + SOFT_BIAS);
			val -= dval;
		    }
		}
		phAtlasImagePixelSet(children[best_k]->aimage, c, y, x,
				     phAtlasImagePixelGet(children[best_k]->aimage, c, y, x) + val); /* left over flux*/
	    }
#else
	    val = phAtlasImagePixelGet(children[0]->parent->aimage, c, y, x) - SOFT_BIAS;
	    max = -1e9; best_k = 0;
	    for(k = 0; k < nchild; k++) {
	       child = children[k];
	       drow = y - child->rowc + 0.5;
	       dcol = x - child->colc + 0.5;
	       r2 = drow*drow + dcol*dcol;
	       if(r2 == 0) {
		  best_k = k; break;
	       }

	       weight = Is2[k]/r2;

	       if(weight > max) {
		  max = weight; best_k = k;
	       }
	    }
	    phAtlasImagePixelSet(children[best_k]->aimage, c, y, x, val + SOFT_BIAS);
#endif
	    unassigned += val;
	 }
      }
   }

   return(unassigned);
}

