#include "phMergeColors.h"
#include "phSignals.h"

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 * Given an OBJECT, grow it by extracting a profile and seeing where that
 * profile exceeds some threshold. The original OBJECT is unaltered, but
 * is presumably slated to be replaced by the new one
 *
 * Return the new OBJECT, unless the input OBJECT has no good pixels
 * (i.e. !NOTCHECKED), in which case return NULL
 */
OBJECT *
phObjectGrowFromProfile(const OBJECT *obj, /* the original OBJECT */
			int level,	/* the desired level */
			const REGION *reg, /* found in this REGION */
			const FRAMEPARAMS *fparams, /* gain etc. */
			float thresh,	/* threshold to grow to */
			int set_sectors, /* no. of sectors above threshold
					    to mask the entire annulus*/
			int clip,	/* how to clip */
			float rat,	/* critical axis ratio for linear
					   features */
			int npix_min,	/* min number of pixels for linear
					   features */
			int rad		/* max radius for profile */
			)
{
   float aratio = 0, majaxis = 0;	/* a/b and p.a. of major axis */
   float colc, rowc;			/* centre of object */
   OBJMASK *goodmask;			/* OBJMASK of good pixels */
   OBJECT *new;
   int npix;				/* number of pixels in object */
   CELL_STATS *prof;			/* extracted profile */
   SPANMASK *regmask;			/* (SPANMASK *)reg->mask */

   shAssert(obj != NULL && level >= 0 && level < obj->nlevel);
   shAssert(reg->mask != NULL);
   regmask = (SPANMASK *)reg->mask;
   shAssert(regmask->cookie == SPAN_COOKIE);
   shAssert(fparams != NULL);
/*
 * Examine list of detected spans, looking for the dimensions and size
 * of the object. We have to ignore bad pixels first
 */
   goodmask = phObjmaskNotIntersectionObjmaskChain(obj->sv[level],
					    regmask->masks[S_MASK_NOTCHECKED]);

   if(goodmask->nspan == 0) {		/* invalid object */
      phObjmaskDel(goodmask);
      return(NULL);
   }

   phObjmaskShape(goodmask,&npix,NULL,NULL,NULL,NULL,NULL,&aratio,&majaxis);
   colc = obj->colc; rowc = obj->rowc;

   if(npix > npix_min && 1/(aratio + 1e-8) > rat) {
      int bin = 2;			/* how much to bin linear extraction */
      int hwidth = 30;			/* half width for   "  "    "    "   */
      int len = 20;			/* section length for  "        "   */

      thresh += fparams->bkgd + SOFT_BIAS;
      new = phLinearFeatureFind(reg,obj,majaxis, 1, hwidth, bin, len, thresh);
   } else {
      if(phSaturatedStarCentroid(reg,obj->sv[0],NULL,
				 fparams->bkgd + SOFT_BIAS,&colc, &rowc) != 0) {
	 colc = obj->colc; rowc = obj->rowc;
      }
      prof = phProfileExtract(-1, -1, reg, rowc, colc, rad, fparams->bkgd,0,0);
      shAssert(prof != NULL && prof->nannuli > 0);
#if 0
      thresh += phProfileMedian(prof,prof->nannuli - 1,clip);
#else
      thresh += fparams->bkgd + SOFT_BIAS;
#endif
      new = phObjectNewFromProfile(prof,reg->ncol,reg->nrow,
						    thresh, set_sectors, clip);
   }

   phObjectPropertiesCopy(new,obj);
   new->colc = colc; new->rowc = rowc;
#if 0					/* XXX */
/*
 * Now deal with diffraction spikes
 */
   if(reg->ROWS[new->peaks.peaks[0].rpeak][new->peaks.peaks[0]->cpeak] >10000){
      float rotator = 1;		/* rotator angle */
      const float rot=rotator*at_deg2Rad;
      int nval;
      int rad = 500;
      float *sec = phXsectionExtract((REGION *)reg,
				     new->rowc - rad*sin(rot),
				     new->colc - rad*cos(rot),
				     new->rowc + rad*sin(rot),
				     new->colc + rad*cos(rot),
				     5,&nval);
      {
	 FILE *fil = fopen("foo","w");
	 int i; for(i = 0;i < nval;i++) { fprintf(fil,"%d %g\n",i,sec[i]); }
	 fclose(fil);
      }
   }
#endif
   
   phObjmaskDel(goodmask);

   return(new);
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Given a chain of objects found by running the object finder on a
 * binned image, convert them to the equivalent objects found in the
 * unbinned image, correcting for scale changes and offsets
 */
void
phObjectChainUnbin(CHAIN *objects,	/* the chain of OBJECTs */
		   int rbin,		/* binning in row direction */
		   int cbin,		/* binning in column direction */
		   int row0,		/* origin of binned image */
		   int col0,		/*                   in parent */
		   int nrow, int ncol)	/* size of unbinned region, or -1 */
{
   int i, j, k;
   int lev;				/* level in OBJECT */
   int ni;				/* counter for spans in nmask */
   int nobj;				/* number of objects on chain */
   OBJECT *obj;				/* OBJECT to unbin */
   OBJMASK *omask, *nmask;		/* old and new OBJMASK */
   const char *object_type = (char *)shTypeGetFromName("OBJECT");

   shAssert(objects != NULL && objects->type == (TYPE)object_type);


   if(ncol <= 0) {
      shAssert(sizeof(ncol) >= 4);
      ncol = MAX_S32;
   }
   if(nrow <= 0) {
      shAssert(sizeof(nrow) >= 4);
      nrow = MAX_S32;
   }

   nobj = shChainSize(objects);
   for(k = 0; k < nobj; k++) {
      obj = shChainElementGetByPos(objects, k);
   
      obj->rowc *= rbin; obj->rowc += row0;
      obj->rowcErr *= rbin;
      obj->colc *= cbin; obj->colc += col0;
      obj->colcErr *= cbin;
      if(rbin == 2 && cbin == 2) {
	 obj->flags |= OBJECT1_BINNED2;
      } else if(rbin == 4 && cbin == 4) {
	 obj->flags |= OBJECT1_BINNED4;
      } else {
	 shFatal("I don't know what flag to set for %dx%d binning", rbin,cbin);
      }

      for(lev = 0; lev < obj->nlevel; lev++) {
	 shAssert(obj->sv[lev]->data == NULL);
	 
	 if(obj->sv[lev]->nspan == 0) {
	    continue;
	 }
	 
	 omask = obj->sv[lev];
	 nmask = phObjmaskNew(rbin*omask->nspan);
	 for(i = ni = 0; i < omask->nspan; i++) {
	    int ox1 = col0 + cbin*omask->s[i].x1;
	    int ox2 = col0 + cbin*omask->s[i].x2;
	    int oy = row0 + rbin*omask->s[i].y;

	    if(ox1 < 0) {
	       ox1 = 0;
	    } else if(ox2 >= ncol) {
	       ox2 = ncol - 1;
	    }
	    if(ox2 < ox1) {
	       continue;
	    }
	    
	    for(j = 0;j < rbin;j++, ni++) {
	       if(oy + j < 0 || oy + j >= nrow) {
		  ni--;			/* it'll be ++ed */
		  continue;
	       }

	       nmask->s[ni].y = oy + j;
	       nmask->s[ni].x1 = ox1;
	       nmask->s[ni].x2 = ox2;
	    }
	 }
	 nmask->nspan = ni;
	 shAssert(nmask->nspan <= nmask->size);

	 nmask->row0 = rbin*omask->row0 + row0;
	 nmask->col0 = cbin*omask->col0 + col0;

	 phObjmaskDel(obj->sv[lev]);
	 phCanonizeObjmask(nmask, 1);
	 obj->sv[lev] = nmask;
      }

      for(i = 0; i < obj->peaks->npeak; i++) {
	 PEAK *const peak = obj->peaks->peaks[i];
	 peak->rpeak *= rbin; peak->rpeak += row0;
	 peak->cpeak *= cbin; peak->cpeak += col0;

	 peak->rowc *= rbin; peak->rowc += row0;
	 peak->rowcErr *= rbin;
	 peak->colc *= cbin; peak->colc += col0;
	 peak->colcErr *= cbin;

	 peak->peak /= rbin;		/* XXX */
      }
   }
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Grow an <lev> level in an OBJECT out by <n> pixels in all directions.
 * We require that the OBJECT's level has at least one pixel
 *
 * See phObjmaskGrow() for description of growing algorithm
 */
OBJECT *
phObjectGrow(const OBJECT *obj,		/* OBJECT to grow */
	     int lev,			/* desired level */
	     const REGION *reg,		/* REGION that obj lives in */
	     int n			/* by how many pixels to grow */
	     )
{
   int i;
   OBJECT *onew;			/* new object */

   shAssert(obj != NULL);
   shAssert(lev >= 0 && lev < obj->nlevel);

   onew = phObjectNew(obj->nlevel);
   for (i = 0; i < obj->nlevel; i++) {
       OBJMASK *omnew = NULL;

       if (i == lev) {
	   omnew = phObjmaskGrow(obj->sv[i], reg, n);
       } else {
	   omnew = obj->sv[i];
	   obj->sv[i]->refcntr++;
       }

       phObjmaskDel(onew->sv[i]);
       onew->sv[i] = omnew;
   }
   
   return(onew);
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Grow a chain of OBJECTs, merging objects that have grown into each other.
 * The growth/merging is only carried out on the specified level, but all
 * levels of the objects are merged; this may lead to non-connected OBJMASKs.
 *
 * There is also the problem of centres; 
 */
void
phObjectChainGrow(CHAIN *chain,		/* the chain of OBJECTs to grow */
		  int lev,		/* desired level */
		  const REGION *reg,	/* REGION that objects live in */
		  int n			/* by how many pixels to grow */
		  )
{
   CURSOR_T curs1, curs2;		/* cursors for chain */
   OBJECT *obj1;			/* OBJECT to grow */
   OBJECT *obj2;			/* another OBJECT on the chain */
   char *object_type = (char *)shTypeGetFromName("OBJECT");

   shAssert(chain != NULL && chain->type == (TYPE)object_type);
   shAssert(reg != NULL && reg->type == TYPE_PIX);
   shAssert(lev >= 0);
   
   curs1 = shChainCursorNew(chain);
   while(phTimeLeft >= 0 && (obj1 = shChainWalk(chain,curs1,NEXT)) != NULL) {
      if(lev >= obj1->nlevel || obj1->sv[lev]->nspan == 0) {
	 continue;
      }
      
      obj2 = phObjectGrow(obj1,lev,reg,n);
      
      phObjmaskDel(obj1->sv[lev]);	/* now replace old OBJMASK by new */
      obj1->sv[lev] = obj2->sv[lev];
      obj2->sv[lev] = NULL;
      phObjectDel(obj2);
   }
   shChainCursorDel(chain,curs1);
/*
 * We've grown all of the objects, now try merging them
 */
   curs1 = shChainCursorNew(chain);
   curs2 = shChainCursorNew(chain);
   while(phTimeLeft >= 0 && (obj1 = shChainWalk(chain,curs1,NEXT)) != NULL) {
      if(lev >= obj1->nlevel || obj1->sv[lev]->nspan == 0) {
	 continue;
      }
      
      shChainCursorSet(chain, curs2, HEAD);
      while(phTimeLeft >= 0 && (obj2 = shChainWalk(chain,curs2,NEXT)) != obj1) {
	 if(phObjmaskIntersect(obj1->sv[lev], obj2->sv[lev],0,0)) {
/*
 * The two overlap. Merge all levels of both objects into obj1, then
 * delete obj2. Note that levels that don't overlap will still be merged,
 * leading to a non-connected OBJMASK
 */
	    (void)shChainElementRemByCursor(chain, curs2);
	    phObjectUnion(obj1, obj2, reg);
	 }
      }
/*
 * If the object only had PEAK_IN_BRIGHT peaks it will now have _no_
 * peaks; if so, delete it.
 */
      if(obj1->peaks->npeak == 0) {
	 (void)shChainElementRemByCursor(chain, curs1);
	 phObjectDel(obj1);
      }
   }

   shChainCursorDel(chain,curs1);
   shChainCursorDel(chain,curs2);
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Trim a chain of OBJECTs, throwing away those with less than npix pixels
 */
void
phObjectChainTrim(CHAIN *objChain,	/* the chain of OBJECTs to grow */
		  int lev,		/* desired level */
		  int npixmin		/* minimum number of pixels */
		  )
{
   CURSOR_T curs;			/* cursor for chain */
   OBJECT *obj;				/* an object on the chain */

   shAssert(objChain != NULL && objChain->type == shTypeGetFromName("OBJECT"));
   shAssert(lev >= 0);
   
   curs = shChainCursorNew(objChain);
   while((obj = shChainWalk(objChain, curs, NEXT)) != NULL) {
      if(lev >= obj->nlevel || obj->sv[lev]->npix < npixmin) {
	  shChainElementRemByCursor(objChain, curs);
	  phObjectDel(obj);
      }
   }
   shChainCursorDel(objChain, curs);
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 * Set a SPANMASK from a CHAIN of OBJECTs
 */
void
phSpanmaskSetFromObjectChain(
			     const CHAIN *chain, /* array of objects */
			     SPANMASK *mask, /* mask to set */
			     S_MASKTYPE val, /* select which mask to use (e.g.
						S_MASK_OBJECT) */
			     int level	/* desired level */
			     )
{
   CURSOR_T curs;			/* cursor for chain */
   OBJECT *obj;
   char *object_type = (char *)shTypeGetFromName("OBJMASK");

   shAssert(chain != NULL && chain->type == shTypeGetFromName("OBJECT"));
   shAssert(level >= 0);
   shAssert(mask != NULL);
   shAssert(val < NMASK_TYPES);
/*
 * Examine list of detected spans, setting the SPANMASK.
 */
   curs = shChainCursorNew(chain);
   while((obj = shChainWalk(chain,curs,NEXT)) != NULL) {
      if(level >= obj->nlevel || obj->sv[level]->nspan == 0) {
	 continue;
      }

      (void)shChainElementAddByPos(mask->masks[val],
				   phObjmaskCopy(obj->sv[level],0,0),
				   object_type, TAIL,AFTER);
   }
   shChainCursorDel(chain,curs);
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 * Set a SPANMASK from the OBJECT1->mask fields of a CHAIN of OBJECT1s
 */
void
phSpanmaskSetFromObject1Chain(
			     const CHAIN *chain, /* array of object1s */
			     SPANMASK *mask, /* mask to set */
			     S_MASKTYPE val /* select which mask to use (e.g.
						S_MASK_OBJECT) */
			     )
{
   CURSOR_T curs;			/* cursor for chain */
   OBJECT1 *obj1;

   shAssert(chain != NULL && chain->type == shTypeGetFromName("OBJECT1"));
   shAssert(mask != NULL);
   shAssert(val < NMASK_TYPES);
/*
 * do the work
 */
   curs = shChainCursorNew(chain);
   while((obj1 = shChainWalk(chain,curs,NEXT)) != NULL) {
      phObjmaskAddToSpanmask(phObjmaskCopy(obj1->mask,0,0),mask,val);
   }
   shChainCursorDel(chain,curs);
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * OR a set of values into a CHAIN of OBJECT's flags2 field, only setting
 * OBJECTS detected at level <level>
 */
void
phObjectChainFlags2Set(CHAIN *objects,
		       int level,
		       int flags2)
{
   int i;
   int len;				/* length of chain */
   OBJECT *obj;				/* an object on the chain */

   shAssert(objects != NULL && objects->type == shTypeGetFromName("OBJECT"));
   shAssert(level >= 0);

   len = shChainSize(objects);
   for(i = 0; i < len; i++) {
      obj = shChainElementGetByPos(objects,i);
      if(level < obj->nlevel && obj->sv[level] != NULL) {
	 obj->flags2 |= flags2;
      }
   }
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * OR a set of values into a CHAIN of OBJECT's flags3 field, only setting
 * OBJECTS detected at level <level>
 */
void
phObjectChainFlags3Set(CHAIN *objects,
		       int level,
		       int flags3)
{
   int i;
   int len;				/* length of chain */
   OBJECT *obj;				/* an object on the chain */

   shAssert(objects != NULL && objects->type == shTypeGetFromName("OBJECT"));
   shAssert(level >= 0);

   len = shChainSize(objects);
   for(i = 0; i < len; i++) {
      obj = shChainElementGetByPos(objects,i);
      if(level < obj->nlevel && obj->sv[level] != NULL) {
	 obj->flags3 |= flags3;
      }
   }
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * OR a set of values into a CHAIN of OBJECT1s flags field
 */
void
phObject1ChainFlagsSet(CHAIN *chain,	/* chain to set */
		       int obj1_flags)	/* value to OR into obj1->flags */
{
   int i;
   int len;				/* length of chain */
   OBJECT1 *obj1;			/* an object on the chain */

   shAssert(chain != NULL && chain->type == shTypeGetFromName("OBJECT1"));

   len = shChainSize(chain);
   for(i = 0; i < len; i++) {
      obj1 = shChainElementGetByPos(chain,i);
      obj1->flags |= obj1_flags;
   }
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 * Convert an OBJECT to an OBJECT1. The OBJECT is deleted
 *
 * This function always return a valid OBJECT1
 */
OBJECT1 *
phObjectToObject1Convert(OBJECT *obj, /* object to convert */
			 int level,	/* desired level */
			 const REGION *reg, /* region where obj was found */
			 float sky	/* sky level at object */
			 )
{
   OBJECT1 *obj1 = phObject1New();	/* the OBJECT1 to return */
   int nspan;				/* unpack obj->nspan for compiler */
   SPANMASK *regmask;			/* (SPANMASK *)reg->mask */

   shAssert(obj != NULL && level >= 0 && level < obj->nlevel);
   shAssert(obj->sv[level]->nspan > 0);
   shAssert(reg != NULL && reg->type == TYPE_PIX);
   shAssert(reg->mask != NULL);
   regmask = (SPANMASK *)reg->mask;
   shAssert(regmask->cookie == SPAN_COOKIE);
/*
 * Examine list of detected spans, looking for the dimensions and size
 * of the object
 */
   obj1->colc = obj->colc; obj1->rowc = obj->rowc;
   obj1->colcErr = obj->colcErr; obj1->rowcErr = obj->rowcErr;

   shAssert(obj1->peaks == NULL);
   obj1->peaks = obj->peaks;
   obj->peaks = NULL;

   phObjmaskShape(obj->sv[level],&obj1->npix, NULL, NULL, NULL, NULL, NULL,
		  &obj1->aratio,&obj1->majaxis);

   obj1->sky = sky;			/* just a first guess */
   obj1->skyErr = ERROR_IS_BAD;		/* no idea yet */
   obj1->flags |= obj->flags;
   obj1->flags2 |= obj->flags2;
   obj1->flags3 |= obj->flags3;
/*
 * Set the mask of where the object was detected
 */
   nspan = obj->sv[level]->nspan;
   obj1->mask = phObjmaskNew(nspan);
   obj1->mask->nspan = nspan;
   memcpy(obj1->mask->s, obj->sv[level]->s, nspan*sizeof(SPAN)); 
   phObjmaskBBSet(obj1->mask);
   
   shAssert(phObjmaskIsCanonical(obj1->mask));

   phObjectDel(obj);
   
   return(obj1);
}

/*****************************************************************************/
/*
 * <AUTO>
 * Convert a CHAIN of OBJECTs to OBJECT1s
 *
 * A new chain is always returned
 *
 * The original CHAIN is emptied, but not deleted
 */
CHAIN *
phObjectToObject1ChainConvert(CHAIN *chain, /* chain of OBJECTs */
			      int lev,	/* desired level */
			      const REGION *reg, /* region where objects were
						    found */
			      const BINREGION *skyreg /* sky levels for reg */
			      )
{
   char *type = (char *)shTypeGetFromName("OBJECT1");
   CHAIN *chain1 = shChainNew(type);
   CURSOR_T curs;
   OBJECT *obj;
   OBJECT1 *obj1;
   float sky;

   shAssert(chain != NULL);
   shAssert(chain->type == shTypeGetFromName("OBJECT"));
/*
 * Build the new list. Adding elements cannot return an error,
 * so don't check for one
 */
   curs = shChainCursorNew(chain);
   while(shChainWalk(chain,curs,NEXT) != NULL) {
      obj = shChainElementRemByCursor(chain,curs);
      shAssert(obj != NULL);
      if(lev >= obj->nlevel || obj->sv[lev]->nspan == 0) { /* level not present
							      in this OBJECT */
	 phObjectDel(obj);
	 continue;
      }
      sky = phBinregionInterpolate(skyreg, obj->rowc, obj->colc);
      obj1 = phObjectToObject1Convert(obj,lev,reg,sky);
      shAssert(obj1 != NULL);
      
      (void)shChainElementAddByPos(chain1,obj1,type,TAIL,AFTER);
   }
   shChainCursorDel(chain,curs);

   return(chain1);
}





/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Find the centre of an OBJECT (see also phObject1CenterFit)
 *
 * If the object contains saturated pixels, use phSaturatedStarCentroid;
 * otherwise find the position of the image's maximum.
 *
 * It is expected that this routine be used on a _smoothed_ region; in
 * the case that the region has been smoothed with the PSF this is equivalent
 * to a MLE fit for the centre using the PSF, if the peak counts are less
 * than sky
 *
 * When the object's peak is in an edge pixel we are unable to fit, so the
 * centre of the peak pixel is found; this is also what we do when the
 * reported peak pixel is not the highest in its vicinity --- something
 * that can happen if some of the pixels are masked
 */
void
phObjectCenterFit(OBJECT *obj,		/* the OBJECT in question */
		  const REGION *in,	/* region containing obj */
		  const FRAMEPARAMS *fparams, /* gain etc. */
		  CENTROID_FLAGS cflags)	/* control the centroiding */
{
   int use_mean = 1;			/* XXX */
   shAssert(obj != NULL && obj->peaks != NULL && obj->peaks->peaks[0] != NULL);

   object_center_fit(obj->peaks->peaks[0],
		     &obj->flags, &obj->flags2, obj->sv[0],
		     &obj->rowc, &obj->rowcErr,
		     &obj->colc, &obj->colcErr, in, fparams, 32,
		     use_mean, cflags);
}

/*
 * <AUTO EXTRACT>
 *
 * Like phObjectCenterFit (q.v.), but for an OBJECT1
 */
void
phObject1CenterFit(OBJECT1 *obj1,	/* the OBJECT1 in question */
		   const REGION *in,	/* region containing obj1 */
		   const FRAMEPARAMS *fparams, /* gain etc. */
		   int binmax,		/* maximum allowed binning */
		   CENTROID_FLAGS cflags) /* control the centroiding */
{
   int use_mean = 1;			/* XXX */

   shAssert(obj1 != NULL && obj1->peaks != NULL);
   shAssert(obj1->peaks->npeak > 0 && obj1->peaks->peaks[0] != NULL);

   if(!(obj1->flags & OBJECT1_DETECTED)) {
      return;				/* we cannot find the centre */
   }
   
   object_center_fit(obj1->peaks->peaks[0],
		     &obj1->flags, &obj1->flags2, obj1->mask,
		     &obj1->rowc, &obj1->rowcErr,
		     &obj1->colc, &obj1->colcErr, in, fparams, binmax,
		     use_mean, cflags);
   /*
    * If the new peak value is smaller it could have spoiled the
    * sorting of the peak list;  check and sort if necessary
    */
   if (obj1->peaks->npeak > 1 &&
       obj1->peaks->peaks[0]->peak < obj1->peaks->peaks[1]->peak) {
       phPeaksSort(obj1->peaks);
   }
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 * 
 * Calculate various geometrical properties of the given OBJMASK;
 * any (or even all) of the pointers may be NULL, in which case the
 * corresponding parameter isn't returned.
 */
void
phObjmaskShape(const OBJMASK *om,	/* object to convert */
	       int *npixel,		/* number of pixels in OBJMASK */
	       float *cc, float *rc,	/* centroid of OBJMASK */
	       float *Mcc, float *Mcr, float *Mrr, /* second moments */
	       float *rat, float *pa	/* axis ratio and position angle
					   of major axis */
	       )
{
   int i;
   int npix;				/* number of pixels in object */
   int n;				/* number of points in a span */
   int nspan;				/* unpack obj->nspan for compiler */
   SPAN *spans;				/* SPANs in this OBJECT */
   float sumc, sumr, sumcc, sumcr, sumrr;
   int y, x1, x2;			/* unpacked from a SPAN */
   int ixc, iyc;			/* the middle pixel */
   float xc, yc;			/* centroid of OBJMASK */
   float w_cc, w_cr, w_rr;		/* second moments */
   float aratio, pos_angle;		/* axis ratio and position angle
					   of major axis */

   shAssert(om != NULL && om->nspan != 0);
   
   spans = om->s;
   nspan = om->nspan;

   ixc = (om->cmax + om->cmin)/2;	/* an initial guess, improves  */
   iyc = (om->rmax + om->rmin)/2;	/* numerical stability of estimates */
   
   npix = 0;
   sumc = sumr = sumcc = sumcr = sumrr = 0.0;
   for(i = 0;i < nspan;i++) {
      y = spans[i].y - iyc; x1 = spans[i].x1 - ixc; x2 = spans[i].x2 - ixc;
      n = (x2 - x1 + 1);
      npix += n;
      sumc += n*((n - 1) + 2*x1);
      sumr += n*y;
      sumcc += n*((n - 1)*(2*n - 1) + 6*x1*((n - 1) + x1));
      sumcr += n*y*((n - 1) + 2*x1);
      sumrr += n*y*y;
   }
   sumc /= (npix*2);
   sumr /= npix;
   sumcc /= (npix*6);
   sumcr /= (npix*2);
   sumrr /= npix;

   xc = ixc + sumc + 0.5;		/* (0.5, 0.5) is the middle */
   yc = iyc + sumr + 0.5;		/*            of a pixel */
   w_cc = sumcc - sumc*sumc;
   w_cr = sumcr - sumc*sumr;
   w_rr = sumrr - sumr*sumr;
/*
 * calculate the two principal axes from the moments, and the position
 * angle of the major axis, with a row having an angle of 0,
 * (all angles are in [0,180)).
 *
 * Note that saoimage displays upside down by default...
 *
 *    Row
 *     ^
 *     |     /
 *     |    /
 *     |   /
 *     |  /
 *     | /\\Theta
 * ____|/__\\________\ Column
 *     |             /
 *     |
 *     |
 *     |
 */
   {
      float a, b;

      a = ((w_cc + w_rr) + sqrt(pow(w_cc - w_rr,2) + 4*pow(w_cr,2)))/2;
      if(a > 1e-5) {
	 b = (w_cc*w_rr - pow(w_cr,2))/a;
	 aratio = b/a;
      } else {
	 aratio = 1e10;
      }
      pos_angle = 0.5*atan2(2*w_cr, w_cc - w_rr)*at_rad2Deg;
      if(pos_angle != pos_angle) {	/* NaN */
	 pos_angle = 0;
      } else if(pos_angle < 0) {
	 pos_angle += 180;
      }
   }
/*
 * pack up answers
 */
   if(npixel != NULL) *npixel = npix;
   if(cc != NULL) *cc = xc;
   if(rc != NULL) *rc = yc;
   if(Mcc != NULL) *Mcc = w_cc;
   if(Mcr != NULL) *Mcr = w_cr;
   if(Mrr != NULL) *Mrr = w_rr;
   if(rat != NULL) *rat = aratio;
   if(pa != NULL) *pa = pos_angle;
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 * Find the extent of a linear feature, given its centre and bounding box
 *
 * We anticipate that this will be used for bright objects such as meteor
 * trails and diffraction spikes.
 */
OBJECT *
phLinearFeatureFind(
		    const REGION *reg,	/* the region where the object is */
		    const OBJECT *obj,	/* the object to investigate */
		    float majaxis,	/* pos. angle of major axis (degrees)*/
		    int follow_ridge,	/* follow ridgeline? */
		    int hwidth,		/* half width for extraction */
		    int bin,		/* bin size for extraction */
		    int len,		/* length of sectors to use */
		    float thresh	/* threshold to follow ridgeline to */
		    )
{
   float cost, sint;			/* {cos,sin}(theta) */
   CELL_STATS *cstats;			/* the returned profile */
   int d;				/* go up or down the profile */
   int i;
   int imax;				/* index of max */
   int max;				/* maximum of extracted profile */
   int npix;				/* number of pixels in extracted prof*/
   OBJECT *new;				/* the linear OBJECT being found */
   OBJMASK *objmask;			/* we actually find this OBJMASK */
   float shift;				/* how much to shift ridgeline by */
   int vertical;			/* obect is basically vertical */
   float xc, yc;			/* centre of object (col,row) */
   float x0,y0,x1,y1;			/* two ends of a sector */
   int width;				/* width of masked region */
   int owidth;				/* old value of width */
   int hwidth_l, hwidth_r;		/* half widths to left and right */

   shAssert(reg != NULL && reg->type == TYPE_PIX);
   shAssert(obj != NULL);

   objmask = phObjmaskNew(0);
   
   sint = sin(majaxis); cost = cos(majaxis);
/*
 * Note that definition of vertical must agree with that in extraction code,
 * i.e. |dy| >= |dx|
 */
   vertical = (majaxis >= M_PI/4.0 && majaxis <= 3.0*M_PI/4.0) ? 1 : 0;

   for(d = 0;d < 2;d++) {
      xc = obj->colc - 0.5;
      yc = obj->rowc - 0.5;
      width = -1;
      for(;;) {
	 x0 = xc - len/2*cost; x1 = xc + len/2*cost;
	 y0 = yc - len/2*sint; y1 = yc + len/2*sint;
	 
	 cstats = phProfileExtractLinear(-1,reg,y0,x0,y1,x1,hwidth,bin,0,0);

	 max = cstats->cells[0].qt[1];
	 npix = cstats->cells[0].ntot;
	 imax = 0;
	 for(i = 1;i < cstats->ncell;i++) {
	    if(cstats->cells[i].ntot == 0) {
	       continue;
	    }
	    npix += cstats->cells[i].ntot;
	    
	    if(cstats->cells[i].qt[1] > max) {
	       max = cstats->cells[i].qt[1];
	       imax = i;
	    }
	 }
	 if(npix == 0) {		/* we're off the edge of the region */
	    break;
	 }

	 if(follow_ridge) {		/* fix up centering */
	    shift = cstats->mgeom[imax].col;
	    if(vertical) {
	       x0 += shift/sint;
	       x1 += shift/sint;
	    } else {
	       y0 += shift/cost;
	       y1 += shift/cost;
	    }
	 } else {
	    shift = 0;
	 }
/*
 * extract a proper logarithmically binned profile, and set the mask
 *
 * First find how large an area needs to be masked; work out from ridgeline
 * looking for where the profile crosses the threshold
 */
	 cstats = phProfileExtractLinear(-1,reg,y0,x0,y1,x1,2*hwidth,0,0,0);

	 if(cstats->cells[cstats->ncell/2].qt[1] < thresh) { /* object's below
								threshold */
	    break;
	 }

	 for(i = cstats->ncell/2;i >= 0;i--) {
	    if(cstats->cells[i].qt[1] < thresh) {
	       break;
	    }
	 }
	 hwidth_l = -cstats->mgeom[i].col;
	 
	 for(i = cstats->ncell/2 + 1;i < cstats->ncell;i++) {
	    if(cstats->cells[i].qt[1] < thresh) {
	       break;
	    }
	 }
	 hwidth_r = cstats->mgeom[i].col;

	 owidth = width;
	 width = hwidth_l + hwidth_r;
/*
 * see if this area overlaps with the previous one masked; if it doesn't
 * then we are done.
 */
	 if(owidth >= 0) {		/* not the first area */
	    if(fabs(shift) - width/2 > owidth/2) {
	       break;
	    }
	 }
/*
 * then actually set the mask bits...
 */
	 phObjmaskSetLinear(objmask, reg->ncol, reg->nrow,
					   x0, y0, x1, y1, hwidth_l, hwidth_r);
/*
 * ...and move along object
 */
	 if(d == 0) {
	    xc = x0; yc = y0;
	 } else {
	    xc = x1; yc = y1;
	 }
      }
   }
/*
 * convert OBJMASK to OBJECT
 */
   new = phObjectNew(1);
   phObjmaskDel(new->sv[0]);
   new->sv[0] = objmask;
   phObjectPropertiesCopy(new,obj);
   phCanonizeObjmask(new->sv[0],0);

   return(new);
}

/*****************************************************************************/
/*
 * <AUTO EXTRACT>
 *
 * Merge obj2 into obj1, resulting in the union of two OBJECTs. Note that
 * obj2 is destroyed.
 *
 * The two overlap. Merge all levels of both objects into obj1, then
 * delete obj2. Note that levels that don't overlap will still be merged,
 * leading to a non-connected OBJMASK
 *
 * The centre information is set from the object with the higher peak
 * pixel
 */
void
phObjectUnion(OBJECT *obj1,		/* object1 */
	      OBJECT *obj2,		/* object2 */
	      const REGION *reg		/* the region that obj{1,2} live in */
	      )
{
   int i;
   int copy_vals2;			/* copy values from obj2 to obj1? */
   int nlevel = obj1->nlevel > obj2->nlevel ? obj1->nlevel : obj2->nlevel;
   OBJMASK *uni;

   shAssert(reg != NULL && reg->type == TYPE_PIX);

   for(i = 0;i < nlevel;i++) {
      if(i >= obj1->nlevel) {		/* only in obj2 */
	 phObjmaskDel(obj1->sv[i]);
	 obj1->sv[i] = obj2->sv[i];
	 obj2->sv[i] = NULL;
      } else if(i >= obj2->nlevel) {	/* only in obj1 */
	 ;				/* so nothing to do */
      } else {
	 uni = phObjmaskUnion(obj1->sv[i],obj2->sv[i]);
	 phObjmaskDel(obj1->sv[i]);
	 obj1->sv[i] = uni;
      }
   }
   obj1->nlevel = nlevel;

   copy_vals2 =
	   (obj1->peaks->peaks[0]->peak < obj2->peaks->peaks[0]->peak) ? 1 : 0;

   /*
    * sort the peak lists, so the first is the brightest
    */
   phPeaksSort(obj1->peaks);
   phPeaksSort(obj2->peaks);

   if(phPeaksMerge(obj1->peaks, obj2->peaks, 0, 0, 2, 0, 0) > 1) {
      obj1->flags3 |= OBJECT3_GROWN_MERGED;
   }
   if(copy_vals2) {
      int tmp = obj2->peaks->size;
      obj2->peaks->size = 0;		/* don't copy peak list */
      phObjectPropertiesCopy(obj1,obj2);
      obj2->peaks->size = tmp;
   }

   phObjectDel(obj2);
}

/*****************************************************************************/
/*
 * Set a chain of OBJECT1's satur_DN values
 */
void
phSaturSetInObject1Chain(const REGION *reg, /* region containing objects */
			 CHAIN *objs)	/* chain of objects */
{
   int i;
   CHAIN *inter;			/* Objects overlapping satur. trail */
   int nobj;				/* == shChainSize(objs) */
   int nrow, ncol;			/* == reg->n{row,col} */
   int nsat;				/* number of saturated OBJMASKs */
   CHAIN *obj_chain;			/* chain of object footprints */
   OBJECT1 *obj1;			/* an object on objs */
   int row0, col0;			/* == reg->{row,col}0 */
   OBJMASK *sat;			/* an element of satur_chain */
   CHAIN *satur_chain;			/* the MASK_SATUR OBJMASKs */
   SPANMASK *sm;			/* reg's mask */

   shAssert(reg != NULL);
   nrow = reg->nrow; ncol = reg->ncol;
   row0 = reg->row0; col0 = reg->col0;
   sm = (SPANMASK *)reg->mask;
   shAssert(sm != NULL && sm->cookie == SPAN_COOKIE);
   shAssert(objs != NULL && objs->type == shTypeGetFromName("OBJECT1"));
   nobj = shChainSize(objs);

   satur_chain = sm->masks[S_MASK_SATUR];

   if(satur_chain == NULL) {
      return;				/* no saturated pixels */
   }
/*
 * Build a chain of the footprints of objects that we think might
 * be saturated
 */
   obj_chain = shChainNew("OBJMASK");
   for(i = 0; i < nobj; i++) {
      obj1 = shChainElementGetByPos(objs, i);
      if(obj1->flags3 & OBJECT3_MEASURE_BRIGHT) {
	 shAssert(obj1->mask != NULL);
	 shChainElementAddByPos(obj_chain, obj1->mask, "OBJMASK", TAIL, AFTER);
	 obj1->mask->user = (void *)obj1;
      }
   }
/*
 * Go through saturated chain looking for suitable matches
 */
   nsat = shChainSize(satur_chain);
   for(i = 0; i < nsat; i++) {
      sat = shChainElementGetByPos(satur_chain, i);
      if(sat->rmin <= row0 || sat->rmax >= row0 + nrow ||
	 sat->cmin <= col0 || sat->cmax >= col0 + ncol) {
	 continue;			/* touches edge; sat->sum unreliable */
      }

      inter = phObjmaskIntersectionChain(sat, obj_chain);

      if(inter == NULL) {		/* You can guess what this means */
	 continue;
      }

      if(shChainSize(inter) == 1) {	/* a single intersection*/
	 obj1 = ((OBJMASK *)(shChainElementGetByPos(inter, 0)))->user;
	 shAssert(obj1 != NULL);
	 obj1->flags3 |= OBJECT3_HAS_SATUR_DN;
	 obj1->satur_DN = sat->sum;
      }

      shChainDestroy(inter, (void (*)(void *))phObjmaskDel);
   }
/*
 * Clean up
 */
   for(i = shChainSize(obj_chain) - 1; i >= 0; i--) {
      OBJMASK *om = shChainElementGetByPos(obj_chain, i);
      om->user = NULL;			/* not strictly necessary */
   }
   shChainDel(obj_chain);		/* NOT shChainDestroy()! */
}

/************************************************************************************************************/
/*
 * Remove all objects that have fewer than npix pixels present in the level'th level
 */
void
phObjectChainNpixelMin(CHAIN *objects,	/* CHAIN of OBJECTs */
		       const int npix,	/* minimum number of pixels */
		       const int level)	/* level to check */
{
    CURSOR_T curs;			/* cursor for chain */
    OBJECT *obj;			/* OBJECT to check */

    shAssert(objects != NULL && objects->type == shTypeGetFromName("OBJECT"));
    shAssert(level >= 0);

    curs = shChainCursorNew(objects);
    while((obj = shChainWalk(objects, curs, NEXT)) != NULL) {
	if(level >= obj->nlevel || obj->sv[level]->npix < npix) {
	    (void)shChainElementRemByCursor(objects, curs);
	}
    }
}
